# Load necessary libraries
library(edgeR)        
library(dplyr)        
library(org.Hs.eg.db)  
library(matrixStats)  
library(ggplot2)      
library(ggrepel)      
library(gridExtra)   
library(NMF)          

# Source custom scripts
source("BETi-COVIDHeart/utilities/ggplotColors.R") 
source("BETi-COVIDHeart/utilities/normCounts.R")  

#----------Read in the bulk RNAseq Data generated by Gilsbach et al. 2018 [PRJNA353755]---------------
human_gene_list <- read.table("PRJNA353755.count_raw_symbol.txt",
                              as.is = TRUE,       
                              row.names = 1)      

# Rename the columns to reflect the experimental conditions (fetal and adult samples).
colnames(human_gene_list) <- c("fetal_1", "fetal_2", "fetal_3", "fetal_4",
                               "adult_1", "adult_2", "adult_3", "adult_4")

# Creating a DGEList object -----------------------------------------------
# Create a DGEList object from the count data. This is the standard input
# format for edgeR. The 'genes' argument assigns row names as gene identifiers.
human_dgList <- DGEList(counts = human_gene_list, genes = rownames(human_gene_list))

# Filtering --------------------------------------------------------------
# Filter out genes with low expression. Here, we retain genes that have at
# least 0.5 counts per million (CPM) in at least 4 samples.

# Calculate CPM for all genes across all samples.
countsPerMillion <- cpm(human_gene_list)
summary(countsPerMillion) # Get summary statistics of CPM values

# Identify genes that meet the expression threshold.
keep <- which(rowSums(countsPerMillion > 0.5) >= 4)

# Subset the gene count matrix to keep only the expressed genes.
human_gene_list <- human_gene_list[keep, ]

# Gene annotation and filtering genes -------------------------------------
# Annotate the remaining genes using the org.Hs.eg.db database.
# Retrieve annotations (SYMBOL, ENTREZID, ENSEMBL, GENENAME) for the gene symbols.
ann <- AnnotationDbi::select(org.Hs.eg.db,
                             keys = rownames(human_gene_list),
                             columns = c("SYMBOL", "ENTREZID", "ENSEMBL", "GENENAME"),
                             keytype = "SYMBOL")

# Match the order of annotations to the order of genes in the count matrix.
m <- match(rownames(human_gene_list), ann$SYMBOL)
ann <- ann[m, ]

# Verify that the gene symbols in the count matrix and annotation table match.
table(ann$SYMBOL == rownames(human_gene_list))

# Identify and filter out unwanted gene categories: mitochondrial, ribosomal,
# genes with missing ENTREZ IDs, and MALAT1 (a long non-coding RNA often
# filtered in RNA-seq analyses).

# Identify mitochondrial genes based on their gene name.
mito <- grep("mitochondrial", ann$GENENAME)
length(mito)

# Identify ribosomal protein genes based on their gene name.
ribo <- grep("ribosomal", ann$GENENAME)
length(ribo)

# Identify genes with missing ENTREZ IDs.
missingEZID <- which(is.na(ann$ENTREZID))
length(missingEZID)

# Combine the indices of genes to be removed. Use 'unique' to avoid duplicates.
chuck <- unique(c(mito, ribo, missingEZID, which(rownames(human_gene_list) == "MALAT1")))
length(chuck)

# Remove the unwanted genes from the count matrix.
human_gene_list <- human_gene_list[-chuck, ]

# Remove the corresponding annotations for the filtered genes.
ann <- ann[-chuck, ]

# Verify again that the gene symbols in the count matrix and annotation table match after filtering.
table(ann$SYMBOL == rownames(human_gene_list))

# Perform Multidimensional Scaling (MDS) plot to visualize sample relationships
# based on gene expression profiles. This can help identify potential outliers
# or batch effects.
plotMDS(human_gene_list)

# Normalize the count data -------------------------------------------------
for (i in 1:ncol(human_dgList$counts)) {
  human_dgList$counts[, i] <- log1p(human_dgList$counts[, i] / colSums(human_dgList$counts)[i] * 1000000)
}

# Data Exploration --------------------------------------------------------
# Perform MDS plot on the normalized counts to visualize sample relationships.
plotMDS(human_dgList)

# Calculate row variances of the normalized counts.
human_dgList$rv <- rowVars(human_dgList$counts)

# Order the genes by their row variance in descending order.
human_dgList <- human_dgList[order(human_dgList$rv, decreasing = TRUE), ]

# Write the top 300 most variable gene symbols to a file.
write.csv(human_dgList$genes[1:300, 1], "./bulkRNA.txt")

# Read a list of intersecting genes from a file.
intersect <- read.delim("./intersectGENES.txt", sep = ",", row.names = 1, as.is = TRUE)

# Subset the DGEList to keep only the genes present in the intersection list.
human_dgList <- human_dgList[which(rownames(human_dgList) %in% intersect[, 1]), ]

# Perform Principal Component Analysis (PCA) on the transposed normalized counts.
# 'scale. = TRUE' centers and scales the variables (genes), and 'center = TRUE' only centers.
pca <- prcomp(t(human_dgList$counts), scale. = TRUE, center = TRUE)

# Calculate the percentage of variance explained by each principal component.
percentVar <- pca$sdev^2 / sum(pca$sdev^2)

# Create a data frame for the PCA results of the bulk RNA-seq data.
d <- data.frame(PC1 = pca$x[, 1], PC2 = pca$x[, 2], cluster = rep("NA", ncol(human_dgList$counts)))


# Save a PCA plot to a TIFF file.
tiff("./PCA_merged_wo_adult3105outof600.tiff", units = "in", width = 5, height = 5, res = 300)
ggplot(d[1:4, ], mapping = aes(PC1, PC2)) +
  geom_point(size = 2, shape = 22, colour = "black", fill = "lightgray") +
  geom_point(data = PCA_data[which(PCA_data$cluster == 0), ], colour = "hotpink3", size = 0.1) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 1), ], colour = "goldenrod2", size = 0.1) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 2), ], colour = "forestgreen", size = 0.1) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 3), ], colour = "dodgerblue1", size = 0.1) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 4), ], colour = "brown3", size = 0.1) +
  geom_point(data = d[5:8, ], colour = "black", size = 2, shape = 24, fill = "lightgray") +
  geom_point(data = d[1:4, ], size = 2, shape = 22, fill = "lightgray") +
  theme_bw() # + xlim(-25, 50) + ylim(-40, 10) # Optional x and y axis limits
dev.off()

# Another ggplot combining PCA results with different aesthetics.
ggplot() +
  geom_point(data = PCA_data[which(PCA_data$cluster == 0), ], mapping = aes(PC1, PC2), colour = "hotpink3", size = 0.1, alpha = 0.5) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 1), ], mapping = aes(PC1, PC2), colour = "tan2", size = 0.1, alpha = 0.5) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 2), ], mapping = aes(PC1, PC2), colour = "forestgreen", size = 0.1) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 3), ], mapping = aes(PC1, PC2), colour = "dodgerblue1", size = 0.1) +
  geom_point(data = PCA_data[which(PCA_data$cluster == 4), ], mapping = aes(PC1, PC2), colour = "brown3", size = 0.1) +
  geom_point(data = d[1:4, ], aes(PC1, PC2), size = 2, colour = "black", pch = 15) + # pch=15 is a filled square
  geom_point(data = d[5:8, ], aes(PC1, PC2), colour = "black", size = 2, pch = 17) + # pch=17 is a filled triangle
  theme_bw() 

# Save another PCA plot to a TIFF file 
tiff("./PCA_merged.tiff", units = "in", width = 10, height = 5, res = 300)
dev.off()

# Define a list of human genes of interest (hgene).
hgene <- c("CCN4", "PLK1", "SLC1A5", "MKI67", "CDK1", "ANLN", "CDK4", "CCNB", "AURKB", "PRC1", "E2F1", "HIF1A", "CDC25", "USF1", "CDK10", "CDK2", "DLC1", "SLN", "NUP98", "SIN3B", "CDH6", "AP1G2", "CASP9", "CTBP1", "BRCA1", "CCND", "TCF20", "TOP3B", "RANBP2", "HIRA", "BRD8", "DDx5", "TIA1", "ENSA", "MLLT10", "COPS5", "CENPA", "SLC4A4", "SORL1", "IL15RA", "SYNGR2", "WEE1")

# Convert the intersecting genes to uppercase
hgene <- toupper(intersect.genes)

# Ensure the list of human genes contains only unique entries.
hgene <- unique(hgene)

# Normalize the original (unfiltered) gene counts using the 'normCounts' function
# with log transformation and a pseudocount of 0.5.
log_counts <- normCounts(DGEList(human_gene_list), log = TRUE, prior.count = 0.5)

# Match the human genes of interest to the row names of the (unfiltered) count data.
m <- match(hgene, rownames(human_gene_list))

# Remove any genes of interest that were not found in the count data.
m <- m[!is.na(m)]

# Define a factor representing the experimental groups for the 8 samples.
grp <- factor(c("fetal_1", "fetal_2", "fetal_3", "fetal_4", "adult_1", "adult_2", "adult_3", "adult_4"))

# Define color palette ------------------------------------------------------
myColors <- list(sample = NA)
myColors$sample <- ggplotColors(8) # Generate 8 distinct colors using a custom function
names(myColors$sample) <- levels(grp) # Assign color names based on the levels of the 'grp' factor

# Heatmap of selected genes ------------------------------------------------
pdf(file = "./heatmapWith_out_adult_3.pdf", width = 20, height = 15, onefile = FALSE)
par(mfrow = c(1, 1)) # Set plotting area to 1 row and 1 column
aheatmap(log_counts[m, ],        
         Rowv = NA,              
         Colv = NA,              
         labRow = hgene,         
         labCol = NA,              
         annCol = list(sample = grp), 
         annColors = myColors,     
         fontsize = 10,          
         color = "-RdYlBu",       
         cexRow = 20)           
dev.off()

# Differential gene expression analysis (mouse data - mm9) -----------------
group <- factor(c(1, 1, 1, 1, 2, 2, 2, 2)) # Define groups for the samples
design <- model.matrix(~group)             # Create a design matrix for the linear model
disp <- estimateDisp(mm9_dgList, design)   # Estimate dispersion for GLM
fit <- glmQLFit(disp, design)              # Fit a quasi-likelihood GLM
tr <- glmQLFTest(fit, coef = 2)            # Perform a QLF test for the second coefficient


# Identify top differentially expressed genes
deg <- topTags(tr, n = 15711, p.value = 0.05, sort.by = "logFC")
up_genes <- deg$table$genes[which(deg$table$logFC < 2)] # Genes with logFC < 2


# Gene annotation using biomaRt --------------------------------------------
mart <- useDataset(dataset = "mmusculus_gene_ensembl", useMart("ensembl"))
genes <- getBM(filters = "ensembl_gene_id",
               attributes = c("ensembl_gene_id", "entrezgene_id"),
               values = up_genes,
               mart = mart)
entrezID <- as.numeric(na.omit(genes$entrezgene_id))

# GO term enrichment analysis ----------------------------------------------
go <- goana(entrezID, species = "Mm") # Perform GO analysis for mouse genes
go <- go[go$P.DE < 0.05, ]             # Filter GO terms by p-value
go <- go[order(go$P.DE), ]             # Order GO terms by p-value

# Retrieve GO to gene mappings ---------------------------------------------
DB <- paste("org", "Mm", "eg", "db", sep = ".")
require(DB, character.only = TRUE)

GO2ALLEGS <- paste("org", "Mm", "egGO2ALLEGS", sep = ".")
EG.GO <- AnnotationDbi::toTable(get(GO2ALLEGS))

# Remove duplicated gene-GO term mappings
d <- duplicated(EG.GO[, c("gene_id", "go_id", "Ontology")])
EG.GO <- EG.GO[!d, ]

# Map DE genes to GO terms and retrieve gene symbols -----------------------
de.by.go <- split(EG.GO$gene_id, paste(EG.GO$go_id, EG.GO$Ontology, sep = "."))
de.by.go <- lapply(de.by.go, FUN = function(x) {
  x[x %in% entrezID]
})
go$ont_goID <- paste(rownames(go), go$Ont, sep = ".")
go$Symbol <- rep(NA, dim(go)[1])
library(org.Mm.eg.db)
hs <- org.Mm.eg.db
for (i in 1:dim(go)[1]) {
  interest <- de.by.go[go$ont_goID[i]]
  my.symbols <- unlist(interest)
  symbols <- select(hs, keys = my.symbols, columns = c("ENTREZID", "SYMBOL"), keytype = "ENTREZID")
  # Collapse a list of character into a single string
  go$Symbol[i] <- paste(symbols$SYMBOL, collapse = ", ")
}
write.csv(go, "./Mm_CM_RedvsYellow-down.csv")

# Basic QC - Heatmap of top 50 expressed genes (mouse data) ---------------
select <- order(rowMeans(mm9_dgList$counts), decreasing = TRUE)[1:50]
highexprgenes_counts <- mm9_dgList$counts[select, ]
heatmap(highexprgenes_counts, col = topo.colors(50), margin = c(10, 6))


# Principal Component Analysis (PCA) - mouse data -------------------------
# select data for the top 100 most highly expressed genes
select <- order(rowMeans(mm9_dgList$counts), decreasing = TRUE)[1:100]
highexprgenes_counts <- mm9_dgList$counts[select, ]
# annotate the data with condition group as labels
group_1 <- factor(c("Yellow", "Yellow", "Yellow", "Yellow", "Red", "Red", "Red", "Red"))
colnames(highexprgenes_counts) <- group_1
# transpose the data to have variables (genes) as columns
data_for_PCA <- t(highexprgenes_counts)
dim(data_for_PCA)
## calculate MDS (matrix of dissimilarities) 
mds <- cmdscale(dist(data_for_PCA), k = 3, eig = TRUE)
eig_pc <- mds$eig * 100 / sum(mds$eig)
# plot the PCA (using eigenvalues from MDS)
barplot(eig_pc,
        las = 1,
        xlab = "Dimensions",
        ylab = "Proportion of explained variance (%)", y.axis = NULL,
        col = "darkgrey")
mds <- cmdscale(dist(data_for_PCA))
plot(mds[, 1], -mds[, 2], type = "n", xlab = "PC1(65.33%)", ylab = "PC2(22.44%)", cex.lab = 0.7)
text(mds[, 1], -mds[, 2], rownames(mds), cex = 0.8)
title(main = "PCA: explaining more than half the variability in the dataset", cex.main = 1)

#### HomoSapiens adult CM - Analysis of GSE97728 dataset ------------------
# Reading in the data
human_gene_list <- read.delim("./GSE97728_Normalized_HomoSapiens.txt",
                              as.is = TRUE, row.names = 1)
# Select relevant columns
human_gene_list_raw <- human_gene_list[, c(5, 10:17)]

# Creating a DGEList object
human_dgList <- DGEList(counts = human_gene_list_raw[, -1], genes = rownames(human_gene_list_raw))
colnames(human_dgList) <- c("G0_1", "G0_2", "G1_1", "G1_2", "G2.M_1", "G2.M_2", "EarlyS_1", "EarlyS_2")

# Gene annotation
ann <- select(org.Hs.eg.db, keys = rownames(human_dgList), keytype = "ENSEMBL",
              columns = c("ENTREZID", "SYMBOL", "GENENAME"))
m <- match(rownames(human_dgList), ann$ENSEMBL)
ann <- ann[m, ]
table(ann$ENSEMBL == rownames(human_dgList))

# Filtering unwanted genes (mitochondrial, ribosomal, missing ENTREZ IDs)
mito <- grep("mitochondrial", ann$GENENAME)
ribo <- grep("ribosomal", ann$GENENAME)
missingEZID <- which(is.na(ann$ENTREZID))
chuck <- unique(c(mito, ribo, missingEZID))
human_dgList <- human_dgList[-chuck, ]
ann <- ann[-chuck, ]
table(ann$ENSEMBL == rownames(human_dgList))

# Filtering low-expressed genes
keep <- rowSums(cpm(human_dgList) >= 0.5) >= 2
human_dgList <- human_dgList[keep, ]

# Add gene annotations and length information to the DGEList object
human_dgList$genes <- ann[match(rownames(human_dgList), ann$ENSEMBL), ]
human_dgList$genes$LENGTH <- human_gene_list_raw$Feature.length..base.pairs.[rownames(human_gene_list_raw) %in% rownames(human_dgList)]

# Define sample groups and names
human_dgList$samples$group <- c("G0", "G0", "G1", "G1", "G2.M", "G2.M", "EarlyS", "EarlyS")
human_dgList$samples$name <- c("G0_1", "G0_2", "G1_1", "G1_2", "G2.M_1", "G2.M_2", "EarlyS_1", "EarlyS_2")

# Plotting library sizes and MDS plot for QC
pal <- ggplotColors(length(unique(human_dgList$samples$group)))
par(mfrow = c(1, 2))
barplot(human_dgList$samples$lib.size, names = human_dgList$samples$name, las = 2, cex.names = 0.8,
        ylab = "Library size (cpm)", col = pal[factor(human_dgList$samples$group)],
        cex.axis = 0.5)
plotMDS(human_dgList, col = pal[factor(human_dgList$samples$group)], gene.selection = "common",
        labels = human_dgList$samples$name)
legend("bottomright", legend = levels(factor(human_dgList$samples$group)), text.col = pal)

# Differential expression analysis with voom and limma ---------------------
human_dgList_normalized <- calcNormFactors(human_dgList) # Calculate normalization factors
design <- model.matrix(~0 + factor(human_dgList_normalized$samples$group))
colnames(design) <- levels(factor(human_dgList_normalized$samples$group))
v <- voom(human_dgList_normalized, design, plot = TRUE) # Apply voom transformation
fit <- lmFit(v, design)                                # Fit linear model
c.matrix <- makeContrasts(G1VsG0 = G1 - G0, G1vsG2.M = G1 - G2.M, G1vsEarlyS = G1 - EarlyS,
                          G2.MvsEarlyS = G2.M - EarlyS, G2.MvsG0 = G2.M - G0, G0vsEarlyS = G0 - EarlyS,
                          levels = design) # Define contrasts
fitc <- contrasts.fit(fit, c.matrix)
fit2 <- eBayes(fitc, trend = TRUE, robust = TRUE) # Empirical Bayes for differential expression
fit.treat <- treat(fit2, lfc = 0.5)               # Apply treat for testing against a logFC threshold
dt.fourF <- decideTests(fit.treat)                # Decide on significance of DE
summary(dt.fourF)

# MD plots for each contrast
pdf(file = "logFC=0.5.pdf", width = 20, height = 15, onefile = FALSE)
par(mfrow = c(2, 3))
for (i in 1:6) {
  plotMD(fit.treat, coef = i, status = dt.fourF[, i], hl.col = c("blue", "red"))
  abline(h = 0, col = "grey")
  sig <- dt.fourF[, i] != 0
  if (all(sig == FALSE) != TRUE) {
    symbol <- human_dgList_normalized$genes$SYMBOL[match(rownames(dt.fourF)[sig], human_dgList_normalized$genes$ENSEMBL)]
    text(fit.treat$coefficients[sig, i], labels = symbol, col = "blue", cex = 1)
  }
}
dev.off()

# Heatmap of predefined heart cell type markers (repeated section) ------
hgene <- c("CCN4", "PLK1", "SLC1A5", "MKI67", "CDK1", "ANLN", "CDK4", "CCNB", "AURKB", "PRC1",
           "E2F1", "HIF1A", "CDC25", "USF1", "CDK10", "CDK2", "DLC1", "SLN", "NUP98", "SIN3B",
           "CDH6", "AP1G2", "CASP9", "CTBP1", "BRCA1", "CCND", "TCF20", "TOP3B", "RANBP2", "HIRA",
           "BRD8", "DDx5", "TIA1", "ENSA", "MLLT10", "COPS5", "CENPA", "SLC4A4", "SORL1", "IL15RA",
           "SYNGR2", "WEE1")
log_counts <- normCounts(human_dgList, log = TRUE, prior.count = 0.5)
m <- match(hgene, human_dgList$genes$SYMBOL)
m <- m[!is.na(m)]
par(mfrow = c(1, 1))
new <- log_counts[m, ]
rownames(new) <- human_dgList$genes$SYMBOL[match(rownames(new), rownames(human_dgList))]
aheatmap(new, Rowv = NA, Colv = NA)

# Differential expression results for each contrast
options(digits = 3)
contrast_1 <- topTreat(fit.treat, coef = 1, n = 6, p.value = 0.05)
contrast_2 <- topTreat(fit.treat, coef = 2, n = 30, p.value = 0.05)
contrast_3 <- topTreat(fit.treat, coef = 3, n = 113, p.value = 0.05)
contrast_4 <- topTreat(fit.treat, coef = 4, n = 2, p.value = 0.05)
contrast_5 <- topTreat(fit.treat, coef = 5, n = 153, p.value = 0.05)
contrast_6 <- topTreat(fit.treat, coef = 6, n = 115, p.value = 0.05)

# Identify down-regulated genes for each contrast
down_1 <- contrast_1[contrast_1$logFC < 0, ]
down_1 <- contrast_1[contrast_1$logFC < 0, ]
down_2 <- contrast_2[contrast_2$logFC < 0, ]
down_3 <- contrast_3[contrast_3$logFC < 0, ]
down_4 <- contrast_4[contrast_4$logFC < 0, ]
down_5 <- contrast_5[contrast_5$logFC < 0, ]
down_6 <- contrast_6[contrast_6$logFC < 0, ]

# Identify up-regulated genes for each contrast
up_1 <- contrast_1[contrast_1$logFC > 0, ]
up_2 <- contrast_2[contrast_2$logFC > 0, ]
up_3 <- contrast_3[contrast_3$logFC > 0, ]
up_4 <- contrast_4[contrast_4$logFC > 0, ]
up_5 <- contrast_5[contrast_5$logFC > 0, ]
up_6 <- contrast_6[contrast_6$logFC > 0, ]

# Combine unique ENTREZ IDs of up-regulated genes across all contrasts
entrezID <- unique(c(up_1$ENTREZID, up_2$ENTREZID, up_3$ENTREZID,
                     up_4$ENTREZID, up_5$ENTREZID, up_6$ENTREZID))

# Combine unique ENTREZ IDs of down-regulated genes across all contrasts
entrezID_down <- unique(c(down_1$ENTREZID, down_2$ENTREZID, down_3$ENTREZID,
                          down_4$ENTREZID, down_5$ENTREZID, down_6$ENTREZID))

# Identify shared ENTREZ IDs between up- and down-regulated gene sets
shared <- entrezID_down[match(entrezID, entrezID_down)]

# Display the top differentially expressed genes for the first contrast
topTreat(fit.treat, coef = 1)

# Perform GO term enrichment analysis using topGO 
topGO(goana(fit.treat, geneid = "ENTREZID", trend = "LENGTH"))

# Calculate log-transformed CPM values for normalized counts
logcpm <- cpm(human_dgList_normalized, log = TRUE)

# Differential gene expression analysis (likely a different comparison) ----
group <- factor(c(1, 1, 2, 2, 2, 2, 3, 3, 3, 3)) # Define groups for samples
design <- model.matrix(~group)               # Create a design matrix
disp <- estimateDisp(human_dgList, design)   # Estimate dispersion
fit <- glmQLFit(disp, design)                # Fit GLM
tr <- glmQLFTest(fit, contrast = c(0, 1, -1)) # Perform QLF test for contrast


# Identify top DE genes
deg <- topTags(tr, n = 26002, p.value = 0.05, sort.by = "logFC")
up_genes <- deg$table$genes[which(deg$table$logFC > 2)] 

# Gene annotation using biomaRt (human data) -----------------------------
mart <- useDataset(dataset = "hsapiens_gene_ensembl", useMart("ensembl"))
genes <- getBM(filters = "ensembl_gene_id",
               attributes = c("ensembl_gene_id", "entrezgene_id"),
               values = up_genes,
               mart = mart)
entrezID <- as.numeric(na.omit(genes$entrezgene_id))

# GO term enrichment analysis (human data) --------------------------------
# Using down-regulated genes from the 6th contrast for GO analysis
go <- goana(down_6$ENTREZID, species = "Hs")
go <- go[go$P.DE < 0.05, ]
go <- go[order(go$P.DE), ]

# Retrieve GO to gene mappings (human data) ------------------------------
DB <- paste("org", "Hs", "eg", "db", sep = ".")
require(DB, character.only = TRUE)

GO2ALLEGS <- paste("org", "Hs", "egGO2ALLEGS", sep = ".")
EG.GO <- AnnotationDbi::toTable(get(GO2ALLEGS))

# Remove duplicated gene-GO term mappings
d <- duplicated(EG.GO[, c("gene_id", "go_id", "Ontology")])
EG.GO <- EG.GO[!d, ]

# Map DE genes to GO terms and retrieve gene symbols -----------------------
de.by.go <- split(EG.GO$gene_id, paste(EG.GO$go_id, EG.GO$Ontology, sep = "."))
de.by.go <- lapply(de.by.go, FUN = function(x) {
  x[x %in% entrezID]
})
go$ont_goID <- paste(rownames(go), go$Ont, sep = ".")
go$Symbol <- rep(NA, dim(go)[1])
library(org.Hs.eg.db)
hs <- org.Hs.eg.db
for (i in 1:dim(go)[1]) {
  interest <- de.by.go[go$ont_goID[i]]
  my.symbols <- unlist(interest)
  symbols <- select(hs, keys = my.symbols, columns = c("ENTREZID", "SYMBOL"), keytype = "ENTREZID")
  # Collapse a list of character into a single string
  go$Symbol[i] <- paste(symbols$SYMBOL, collapse = ", ")
}
write.csv(go, "./down_genes.csv")

# Principal Component Analysis (PCA) - human data------
# select data for the top 100 most highly expressed genes
select <- order(rowMeans(human_dgList$counts), decreasing = TRUE)[1:100]
highexprgenes_counts <- human_dgList$counts[select, ]
# annotate the data with condition group as labels
group_1 <- factor(c("Yellow", "Yellow", "Yellow", "Yellow", "Red", "Red", "Red", "Red"))
colnames(highexprgenes_counts) <- group_1
# transpose the data to have variables (genes) as columns
data_for_PCA <- t(highexprgenes_counts)
dim(data_for_PCA)
## calculate MDS (matrix of dissimilarities) 
mds <- cmdscale(dist(data_for_PCA), k = 3, eig = TRUE)
eig_pc <- mds$eig * 100 / sum(mds$eig)
# plot the PCA (using eigenvalues from MDS)
barplot(eig_pc,
        las = 1,
        xlab = "Dimensions",
        ylab = "Proportion of explained variance (%)", y.axis = NULL,
        col = "darkgrey")
mds <- cmdscale(dist(data_for_PCA))
plot(mds[, 1], -mds[, 2], type = "n", xlab = "PC1(65.33%)", ylab = "PC2(22.44%)", cex.lab = 0.7)
text(mds[, 1], -mds[, 2], rownames(mds), cex = 0.8)
title(main = "PCA: explaining more than half the variability in the dataset", cex.main = 1)

